"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./app/src/components/auth/AuthGuard.tsx":
/*!***********************************************!*\
  !*** ./app/src/components/auth/AuthGuard.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_auth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/auth */ \"(app-pages-browser)/./app/src/lib/auth.ts\");\n/**\n * @file AuthGuard.tsx\n * @description A client-side React component that acts as an authentication and authorization guard.\n *              It checks for the presence of an authentication token and, if provided, decodes it\n *              to verify the user's role. It redirects users to the login page if unauthenticated\n *              or to an unauthorized page if they don't have the necessary permissions.\n */ /* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n // React hooks for side effects and state management.\n // Next.js hook for client-side navigation.\n // Utility function to retrieve the authentication token from cookies.\n/**\n * AuthGuard Component\n * @param {AuthGuardProps} props - The props for the AuthGuard component.\n * @returns {JSX.Element | null} The protected child components if authenticated and authorized, otherwise null (or a loading indicator).\n */ const AuthGuard = (param)=>{\n    let { children, allowedRoles } = param;\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)(); // Initialize the Next.js router for navigation.\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false); // State to track user authentication status.\n    const [userRole, setUserRole] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null); // State to store the authenticated user's role.\n    // useEffect hook to perform authentication checks when the component mounts or dependencies change.\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const token = (0,_lib_auth__WEBPACK_IMPORTED_MODULE_3__.getAuthToken)(); // Attempt to retrieve the authentication token.\n        // If no token is found, redirect the user to the login page.\n        if (!token) {\n            router.push(\"/login\");\n            return;\n        }\n        // Attempt to decode the JWT to extract user information, including the role.\n        // NOTE: In a production application, JWT verification should primarily happen on the server-side\n        // to prevent client-side tampering. This client-side decoding is for basic UI logic.\n        try {\n            // JWTs consist of three parts separated by dots: Header.Payload.Signature.\n            // We are interested in the Payload, which is base64Url encoded.\n            const base64Url = token.split(\".\")[1];\n            // Convert base64Url to base64 by replacing URL-safe characters.\n            const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n            // Decode the base64 string and parse the JSON payload.\n            const decoded = JSON.parse(atob(base64));\n            setUserRole(decoded.role); // Set the user's role from the decoded token.\n            // If allowedRoles are specified, check if the user's role is included.\n            if (allowedRoles && !allowedRoles.includes(decoded.role)) {\n                // If the user's role is not allowed, redirect to the unauthorized page.\n                router.push(\"/unauthorized\");\n            } else {\n                // If authenticated and authorized, set isAuthenticated to true to render children.\n                setIsAuthenticated(true);\n            }\n        } catch (error) {\n            // If there's an error decoding the token (e.g., malformed or invalid),\n            // log the error and redirect the user to the login page.\n            console.error(\"Error decoding token:\", error);\n            router.push(\"/login\");\n        }\n    }, [\n        router,\n        allowedRoles\n    ]); // Dependencies: router and allowedRoles to re-run effect if they change.\n    // If not yet authenticated, render nothing (or a loading spinner) to prevent flickering.\n    if (!isAuthenticated) {\n        return null; // Or a loading spinner component.\n    }\n    // If authenticated and authorized, render the child components.\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: children\n    }, void 0, false);\n};\n_s(AuthGuard, \"5txHUYAjDexH17hIpfMAk9tzvNU=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthGuard;\n/* harmony default export */ __webpack_exports__[\"default\"] = (AuthGuard);\nvar _c;\n$RefreshReg$(_c, \"AuthGuard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zcmMvY29tcG9uZW50cy9hdXRoL0F1dGhHdWFyZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7OztDQU1DOztBQUkyQyxDQUFDLHFEQUFxRDtBQUN0RCxDQUFDLDJDQUEyQztBQUMxQyxDQUFDLHNFQUFzRTtBQWFySDs7OztDQUlDLEdBQ0QsTUFBTUksWUFBc0M7UUFBQyxFQUFFQyxRQUFRLEVBQUVDLFlBQVksRUFBRTs7SUFDckUsTUFBTUMsU0FBU0wsMERBQVNBLElBQUksZ0RBQWdEO0lBQzVFLE1BQU0sQ0FBQ00saUJBQWlCQyxtQkFBbUIsR0FBR1IsK0NBQVFBLENBQUMsUUFBUSw2Q0FBNkM7SUFDNUcsTUFBTSxDQUFDUyxVQUFVQyxZQUFZLEdBQUdWLCtDQUFRQSxDQUFnQixPQUFPLGdEQUFnRDtJQUUvRyxvR0FBb0c7SUFDcEdELGdEQUFTQSxDQUFDO1FBQ1IsTUFBTVksUUFBUVQsdURBQVlBLElBQUksZ0RBQWdEO1FBRTlFLDZEQUE2RDtRQUM3RCxJQUFJLENBQUNTLE9BQU87WUFDVkwsT0FBT00sSUFBSSxDQUFDO1lBQ1o7UUFDRjtRQUVBLDZFQUE2RTtRQUM3RSxpR0FBaUc7UUFDakcscUZBQXFGO1FBQ3JGLElBQUk7WUFDRiwyRUFBMkU7WUFDM0UsZ0VBQWdFO1lBQ2hFLE1BQU1DLFlBQVlGLE1BQU1HLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNyQyxnRUFBZ0U7WUFDaEUsTUFBTUMsU0FBU0YsVUFBVUcsT0FBTyxDQUFDLE1BQU0sS0FBS0EsT0FBTyxDQUFDLE1BQU07WUFDMUQsdURBQXVEO1lBQ3ZELE1BQU1DLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ0MsS0FBS0w7WUFDaENMLFlBQVlPLFFBQVFJLElBQUksR0FBRyw4Q0FBOEM7WUFFekUsdUVBQXVFO1lBQ3ZFLElBQUloQixnQkFBZ0IsQ0FBQ0EsYUFBYWlCLFFBQVEsQ0FBQ0wsUUFBUUksSUFBSSxHQUFHO2dCQUN4RCx3RUFBd0U7Z0JBQ3hFZixPQUFPTSxJQUFJLENBQUM7WUFDZCxPQUFPO2dCQUNMLG1GQUFtRjtnQkFDbkZKLG1CQUFtQjtZQUNyQjtRQUNGLEVBQUUsT0FBT2UsT0FBTztZQUNkLHVFQUF1RTtZQUN2RSx5REFBeUQ7WUFDekRDLFFBQVFELEtBQUssQ0FBQyx5QkFBeUJBO1lBQ3ZDakIsT0FBT00sSUFBSSxDQUFDO1FBQ2Q7SUFDRixHQUFHO1FBQUNOO1FBQVFEO0tBQWEsR0FBRyx5RUFBeUU7SUFFckcseUZBQXlGO0lBQ3pGLElBQUksQ0FBQ0UsaUJBQWlCO1FBQ3BCLE9BQU8sTUFBTSxrQ0FBa0M7SUFDakQ7SUFFQSxnRUFBZ0U7SUFDaEUscUJBQU87a0JBQUdIOztBQUNaO0dBbkRNRDs7UUFDV0Ysc0RBQVNBOzs7S0FEcEJFO0FBcUROLCtEQUFlQSxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9zcmMvY29tcG9uZW50cy9hdXRoL0F1dGhHdWFyZC50c3g/OTYwOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEF1dGhHdWFyZC50c3hcbiAqIEBkZXNjcmlwdGlvbiBBIGNsaWVudC1zaWRlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGFjdHMgYXMgYW4gYXV0aGVudGljYXRpb24gYW5kIGF1dGhvcml6YXRpb24gZ3VhcmQuXG4gKiAgICAgICAgICAgICAgSXQgY2hlY2tzIGZvciB0aGUgcHJlc2VuY2Ugb2YgYW4gYXV0aGVudGljYXRpb24gdG9rZW4gYW5kLCBpZiBwcm92aWRlZCwgZGVjb2RlcyBpdFxuICogICAgICAgICAgICAgIHRvIHZlcmlmeSB0aGUgdXNlcidzIHJvbGUuIEl0IHJlZGlyZWN0cyB1c2VycyB0byB0aGUgbG9naW4gcGFnZSBpZiB1bmF1dGhlbnRpY2F0ZWRcbiAqICAgICAgICAgICAgICBvciB0byBhbiB1bmF1dGhvcml6ZWQgcGFnZSBpZiB0aGV5IGRvbid0IGhhdmUgdGhlIG5lY2Vzc2FyeSBwZXJtaXNzaW9ucy5cbiAqL1xuXG4ndXNlIGNsaWVudCc7IC8vIE1hcmtzIHRoaXMgY29tcG9uZW50IGFzIGEgQ2xpZW50IENvbXBvbmVudCwgZW5hYmxpbmcgdGhlIHVzZSBvZiBob29rcyBsaWtlIHVzZVJvdXRlciwgdXNlRWZmZWN0LCBhbmQgdXNlU3RhdGUuXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7IC8vIFJlYWN0IGhvb2tzIGZvciBzaWRlIGVmZmVjdHMgYW5kIHN0YXRlIG1hbmFnZW1lbnQuXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nOyAvLyBOZXh0LmpzIGhvb2sgZm9yIGNsaWVudC1zaWRlIG5hdmlnYXRpb24uXG5pbXBvcnQgeyBnZXRBdXRoVG9rZW4gfSBmcm9tICcuLi8uLi9saWIvYXV0aCc7IC8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIGZyb20gY29va2llcy5cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEF1dGhHdWFyZFByb3BzXG4gKiBAcHJvcGVydHkge1JlYWN0LlJlYWN0Tm9kZX0gY2hpbGRyZW4gLSBUaGUgY2hpbGQgY29tcG9uZW50cyB0aGF0IHRoZSBBdXRoR3VhcmQgd2lsbCBwcm90ZWN0LlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW2FsbG93ZWRSb2xlc10gLSBBbiBvcHRpb25hbCBhcnJheSBvZiByb2xlcyB0aGF0IGFyZSBhbGxvd2VkIHRvIGFjY2VzcyB0aGUgcHJvdGVjdGVkIGNvbnRlbnQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgcHJvdmlkZWQsIHRoZSB1c2VyJ3Mgcm9sZSBtdXN0IGJlIGluIHRoaXMgYXJyYXkuXG4gKi9cbmludGVyZmFjZSBBdXRoR3VhcmRQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIGFsbG93ZWRSb2xlcz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEF1dGhHdWFyZCBDb21wb25lbnRcbiAqIEBwYXJhbSB7QXV0aEd1YXJkUHJvcHN9IHByb3BzIC0gVGhlIHByb3BzIGZvciB0aGUgQXV0aEd1YXJkIGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudCB8IG51bGx9IFRoZSBwcm90ZWN0ZWQgY2hpbGQgY29tcG9uZW50cyBpZiBhdXRoZW50aWNhdGVkIGFuZCBhdXRob3JpemVkLCBvdGhlcndpc2UgbnVsbCAob3IgYSBsb2FkaW5nIGluZGljYXRvcikuXG4gKi9cbmNvbnN0IEF1dGhHdWFyZDogUmVhY3QuRkM8QXV0aEd1YXJkUHJvcHM+ID0gKHsgY2hpbGRyZW4sIGFsbG93ZWRSb2xlcyB9KSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpOyAvLyBJbml0aWFsaXplIHRoZSBOZXh0LmpzIHJvdXRlciBmb3IgbmF2aWdhdGlvbi5cbiAgY29uc3QgW2lzQXV0aGVudGljYXRlZCwgc2V0SXNBdXRoZW50aWNhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTsgLy8gU3RhdGUgdG8gdHJhY2sgdXNlciBhdXRoZW50aWNhdGlvbiBzdGF0dXMuXG4gIGNvbnN0IFt1c2VyUm9sZSwgc2V0VXNlclJvbGVdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7IC8vIFN0YXRlIHRvIHN0b3JlIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIncyByb2xlLlxuXG4gIC8vIHVzZUVmZmVjdCBob29rIHRvIHBlcmZvcm0gYXV0aGVudGljYXRpb24gY2hlY2tzIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHMgb3IgZGVwZW5kZW5jaWVzIGNoYW5nZS5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB0b2tlbiA9IGdldEF1dGhUb2tlbigpOyAvLyBBdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbi5cblxuICAgIC8vIElmIG5vIHRva2VuIGlzIGZvdW5kLCByZWRpcmVjdCB0aGUgdXNlciB0byB0aGUgbG9naW4gcGFnZS5cbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICByb3V0ZXIucHVzaCgnL2xvZ2luJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXR0ZW1wdCB0byBkZWNvZGUgdGhlIEpXVCB0byBleHRyYWN0IHVzZXIgaW5mb3JtYXRpb24sIGluY2x1ZGluZyB0aGUgcm9sZS5cbiAgICAvLyBOT1RFOiBJbiBhIHByb2R1Y3Rpb24gYXBwbGljYXRpb24sIEpXVCB2ZXJpZmljYXRpb24gc2hvdWxkIHByaW1hcmlseSBoYXBwZW4gb24gdGhlIHNlcnZlci1zaWRlXG4gICAgLy8gdG8gcHJldmVudCBjbGllbnQtc2lkZSB0YW1wZXJpbmcuIFRoaXMgY2xpZW50LXNpZGUgZGVjb2RpbmcgaXMgZm9yIGJhc2ljIFVJIGxvZ2ljLlxuICAgIHRyeSB7XG4gICAgICAvLyBKV1RzIGNvbnNpc3Qgb2YgdGhyZWUgcGFydHMgc2VwYXJhdGVkIGJ5IGRvdHM6IEhlYWRlci5QYXlsb2FkLlNpZ25hdHVyZS5cbiAgICAgIC8vIFdlIGFyZSBpbnRlcmVzdGVkIGluIHRoZSBQYXlsb2FkLCB3aGljaCBpcyBiYXNlNjRVcmwgZW5jb2RlZC5cbiAgICAgIGNvbnN0IGJhc2U2NFVybCA9IHRva2VuLnNwbGl0KCcuJylbMV07XG4gICAgICAvLyBDb252ZXJ0IGJhc2U2NFVybCB0byBiYXNlNjQgYnkgcmVwbGFjaW5nIFVSTC1zYWZlIGNoYXJhY3RlcnMuXG4gICAgICBjb25zdCBiYXNlNjQgPSBiYXNlNjRVcmwucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKTtcbiAgICAgIC8vIERlY29kZSB0aGUgYmFzZTY0IHN0cmluZyBhbmQgcGFyc2UgdGhlIEpTT04gcGF5bG9hZC5cbiAgICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IoYmFzZTY0KSk7XG4gICAgICBzZXRVc2VyUm9sZShkZWNvZGVkLnJvbGUpOyAvLyBTZXQgdGhlIHVzZXIncyByb2xlIGZyb20gdGhlIGRlY29kZWQgdG9rZW4uXG5cbiAgICAgIC8vIElmIGFsbG93ZWRSb2xlcyBhcmUgc3BlY2lmaWVkLCBjaGVjayBpZiB0aGUgdXNlcidzIHJvbGUgaXMgaW5jbHVkZWQuXG4gICAgICBpZiAoYWxsb3dlZFJvbGVzICYmICFhbGxvd2VkUm9sZXMuaW5jbHVkZXMoZGVjb2RlZC5yb2xlKSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlcidzIHJvbGUgaXMgbm90IGFsbG93ZWQsIHJlZGlyZWN0IHRvIHRoZSB1bmF1dGhvcml6ZWQgcGFnZS5cbiAgICAgICAgcm91dGVyLnB1c2goJy91bmF1dGhvcml6ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGF1dGhlbnRpY2F0ZWQgYW5kIGF1dGhvcml6ZWQsIHNldCBpc0F1dGhlbnRpY2F0ZWQgdG8gdHJ1ZSB0byByZW5kZXIgY2hpbGRyZW4uXG4gICAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciBkZWNvZGluZyB0aGUgdG9rZW4gKGUuZy4sIG1hbGZvcm1lZCBvciBpbnZhbGlkKSxcbiAgICAgIC8vIGxvZyB0aGUgZXJyb3IgYW5kIHJlZGlyZWN0IHRoZSB1c2VyIHRvIHRoZSBsb2dpbiBwYWdlLlxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVjb2RpbmcgdG9rZW46JywgZXJyb3IpO1xuICAgICAgcm91dGVyLnB1c2goJy9sb2dpbicpO1xuICAgIH1cbiAgfSwgW3JvdXRlciwgYWxsb3dlZFJvbGVzXSk7IC8vIERlcGVuZGVuY2llczogcm91dGVyIGFuZCBhbGxvd2VkUm9sZXMgdG8gcmUtcnVuIGVmZmVjdCBpZiB0aGV5IGNoYW5nZS5cblxuICAvLyBJZiBub3QgeWV0IGF1dGhlbnRpY2F0ZWQsIHJlbmRlciBub3RoaW5nIChvciBhIGxvYWRpbmcgc3Bpbm5lcikgdG8gcHJldmVudCBmbGlja2VyaW5nLlxuICBpZiAoIWlzQXV0aGVudGljYXRlZCkge1xuICAgIHJldHVybiBudWxsOyAvLyBPciBhIGxvYWRpbmcgc3Bpbm5lciBjb21wb25lbnQuXG4gIH1cblxuICAvLyBJZiBhdXRoZW50aWNhdGVkIGFuZCBhdXRob3JpemVkLCByZW5kZXIgdGhlIGNoaWxkIGNvbXBvbmVudHMuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBdXRoR3VhcmQ7Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUm91dGVyIiwiZ2V0QXV0aFRva2VuIiwiQXV0aEd1YXJkIiwiY2hpbGRyZW4iLCJhbGxvd2VkUm9sZXMiLCJyb3V0ZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRJc0F1dGhlbnRpY2F0ZWQiLCJ1c2VyUm9sZSIsInNldFVzZXJSb2xlIiwidG9rZW4iLCJwdXNoIiwiYmFzZTY0VXJsIiwic3BsaXQiLCJiYXNlNjQiLCJyZXBsYWNlIiwiZGVjb2RlZCIsIkpTT04iLCJwYXJzZSIsImF0b2IiLCJyb2xlIiwiaW5jbHVkZXMiLCJlcnJvciIsImNvbnNvbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/src/components/auth/AuthGuard.tsx\n"));

/***/ })

});